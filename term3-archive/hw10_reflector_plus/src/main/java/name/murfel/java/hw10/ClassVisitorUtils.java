package name.murfel.java.hw10;

import java.lang.reflect.*;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

/**
 * Incorporates a structure for implementing a Visitor design pattern for Java classes.
 *
 * It does not support interfaces, enums, or annotations.
 */
public class ClassVisitorUtils {

    /**
     * A part of Visitor design pattern representing a basic block in a Java class tree.
     */
    public static abstract class ReflectedElement {
        protected boolean visitSubclasses;

        ReflectedElement(boolean visitSubclasses) {
            this.visitSubclasses = visitSubclasses;
        }

        abstract void accept(Visitor visitor);
    }

    /**
     * Represents a Java class.
     */
    public static class ClassElement extends ReflectedElement {
        private Class<?> thisClass;

        public ClassElement(Class<?> thisClass, boolean visitSubclasses) {
            super(visitSubclasses);
            this.thisClass = thisClass;
        }

        /**
         * Forward visitor to fields, constructors, methods, and subclasses defined in thisClass.
         * <p>
         * If thisClass has an auto-generated default constructor, visitor will also visit it.
         *
         * @param v a visitor
         */
        @Override
        public void accept(Visitor v) {
            if (thisClass.isSynthetic()) {
                return;
            }
            v.visitClassModifiers(thisClass.getModifiers());
            v.visitClassKeyword();
            v.visitNameWithSpace(thisClass.getSimpleName());
            v.visitTypeParameters(thisClass.getTypeParameters());
            if (thisClass.getGenericSuperclass() != null) {
                v.visitExtendsKeyword();
                v.visitExtendedClass(thisClass.getGenericSuperclass());
            }
            if (thisClass.getGenericInterfaces().length != 0) {
                v.visitImplementsKeyword();
                v.visitImplementedInterfaces(thisClass.getGenericInterfaces());
            }
            v.startVisitingClassScope(thisClass);
            for (Field field : thisClass.getDeclaredFields()) {
                (new FieldElement(field, visitSubclasses)).accept(v);
            }
            for (Constructor<?> constructor : thisClass.getDeclaredConstructors()) {
                (new ConstructorElement(constructor, visitSubclasses)).accept(v);
            }
            for (Method method : thisClass.getDeclaredMethods()) {
                (new MethodElement(method, visitSubclasses)).accept(v);
            }
            for (Class<?> someClass : thisClass.getDeclaredClasses()) {
                (new ClassElement(someClass, visitSubclasses)).accept(v);
            }
            v.finishVisitingClassScope(thisClass);
        }
    }

    /**
     * Represents a Java field.
     */
    public static class FieldElement extends ReflectedElement {
        private Field field;

        public FieldElement(Field field, boolean visitSubclasses) {
            super(visitSubclasses);
            this.field = field;
        }

        /**
         * Forward visitor to field modifiers, type, and name;
         */
        @Override
        public void accept(Visitor v) {
            if (field.isSynthetic()) {
                return;
            }
            v.visitFieldModifiers(field.getModifiers());
            v.visitType(field.getGenericType());
            v.visitName(field.getName());
            v.finishVisitingField(field);
        }
    }

    /**
     * Represents Java constructor.
     */
    public static class ConstructorElement extends ReflectedElement {
        private Constructor<?> constructor;
        private boolean isClassInner;

        public ConstructorElement(Constructor<?> constructor, boolean visitSubclasses) {
            super(visitSubclasses);
            this.constructor = constructor;
            Class<?> declaringClass = constructor.getDeclaringClass();
            isClassInner = declaringClass.getEnclosingClass() != null && !Modifier.isStatic(declaringClass.getModifiers());
        }

        /**
         * Forward visitor to constructor parameters.
         */
        @Override
        public void accept(Visitor v) {
            if (constructor.isSynthetic()) {
                return;
            }
            Class<?> declaringClass = constructor.getDeclaringClass();
            v.visitConstructorModifiers(constructor.getModifiers());
            v.visitName(declaringClass.getSimpleName());
            // If class is inner, then the first parameter to constructor
            // is always a 'syntetic' (generated by compiler) reference to parent's this which we want to avoid
            Type[] parameterTypes = constructor.getGenericParameterTypes();
            if (isClassInner) {
                Type[] newParameterTypes = new Type[parameterTypes.length - 1];
                System.arraycopy(parameterTypes, 1, newParameterTypes, 0, newParameterTypes.length);
                parameterTypes = newParameterTypes;
            }
            v.visitConstructorParameters(parameterTypes);
            v.startVisitingConstructorScope(constructor);
            v.finishVisitingConstructorScope(constructor);
        }
    }

    /**
     * Represents Java method.
     */
    public static class MethodElement extends ReflectedElement {
        private Method method;

        public MethodElement(Method method, boolean visitSubclasses) {
            super(visitSubclasses);
            this.method = method;
        }

        /**
         * Forward visitor to method modifiers, type, name, and parameters.
         */
        @Override
        public void accept(Visitor v) {
            v.visitMethidModifiers(method.getModifiers());
            v.visitType(method.getGenericReturnType());
            v.visitName(method.getName());
            v.visitMethodParameters(method.getGenericParameterTypes());
            v.startVisitingMethodScope(method);
            v.visitMethodScope(method);
            v.finishVisitingMethodScope(method);
        }
    }


    /**
     * The basic visitor class which handles all elements in a way that it converts them into strings
     * representing how they could have appeared in Java source code.
     */
    public static class Visitor {
        protected StringBuilder currentLine;
        private int indentLevel;
        private String indent = "    ";
        private List<String> lines;
        private int parametersCounter;

        /**
         * Traverse a class and collect a list of strings each of which represents a line in Java source code
         * of this class.
         *
         * @param someClass a class to visit
         * @param visitSubclasses set to false to ignore subclasses
         * @return list of lines, as in source code
         */
        public List<String> visit(Class<?> someClass, boolean visitSubclasses) {
            currentLine = new StringBuilder();
            lines = new LinkedList<>();
            visit(new ClassElement(someClass, visitSubclasses));
            return lines;
        }

        public void visit(ReflectedElement element) {
            element.accept(this);
        }

        protected void flushLine() {
            lines.add(currentLine.toString());
            currentLine = new StringBuilder();
        }

        protected void printCurrentIndent() {
            currentLine.append(String.join("", Collections.nCopies(indentLevel, indent)));
        }


        protected void visitTypeParameters(TypeVariable<? extends Class<?>>[] typeParameters) {
            if (typeParameters.length == 0) {
                return;
            }
            currentLine.append('<');
            for (int i = 0; i < typeParameters.length; i++) {
                currentLine.append(typeParameters[i]);
                if (i != typeParameters.length - 1) {
                    currentLine.append(", ");
                }
            }
            currentLine.append('>');
            currentLine.append(' ');
        }

        protected void visitNameWithSpace(String name) {
            visitName(name);
            currentLine.append(' ');
        }

        protected void visitClassKeyword() {
            currentLine.append("class ");
        }

        protected void visitName(String name) {
            currentLine.append(name);
        }

        protected void visitType(Type genericType) {
            currentLine.append(genericType.getTypeName());
            currentLine.append(' ');
        }

        private void visitFunctionParameters(Type[] genericParameterTypes) {
            if (genericParameterTypes.length == 0) {
                currentLine.append("() ");
                return;
            }
            currentLine.append('(');
            for (int i = 0; i < genericParameterTypes.length; i++) {
                visitType(genericParameterTypes[i]);
                visitParameterName();
                if (i != genericParameterTypes.length - 1) {
                    currentLine.append(", ");
                }
            }
            currentLine.append(')');
            currentLine.append(' ');
        }

        protected void visitParameterName() {
            currentLine.append("arg");
            currentLine.append(parametersCounter++);
        }

        protected void visitExtendsKeyword() {
            currentLine.append("extends ");
        }

        protected void visitImplementsKeyword() {
            currentLine.append("implements ");
        }

        protected void visitExtendedClass(Type genericSuperclass) {
            currentLine.append(genericSuperclass.getTypeName());
            currentLine.append(' ');
        }

        protected void visitImplementedInterfaces(Type[] genericInterfaces) {
            for (int i = 0; i < genericInterfaces.length; i++) {
                currentLine.append(genericInterfaces[i]);
                if (i != genericInterfaces.length - 1) {
                    currentLine.append(',');
                }
                currentLine.append(' ');
            }
        }

        protected void visitClassModifiers(int modifiers) {
            visitModifiers(modifiers);
        }

        protected void visitFieldModifiers(int modifiers) {
            visitModifiers(modifiers);
        }

        protected void visitMethidModifiers(int modifiers) {
            visitModifiers(modifiers);
        }

        private void visitModifiers(int modifiers) {
            printCurrentIndent();
            String modifiersString = Modifier.toString(modifiers);
            if (modifiersString.length() != 0) {
                currentLine.append(modifiersString);
                currentLine.append(' ');
            }
        }

        public void visitConstructorModifiers(int modifiers) {
            visitModifiers(modifiers);
        }

        protected void visitConstructorParameters(Type[] parameterTypes) {
            visitFunctionParameters(parameterTypes);
        }

        protected void visitMethodParameters(Type[] genericParameterTypes) {
            visitFunctionParameters(genericParameterTypes);
        }

        protected void startVisitingClassScope(Class<?> thisClass) {
            startVisitingNewScope();
        }

        protected void finishVisitingClassScope(Class<?> thisClass) {
            finishVisitingNewScope();
        }

        protected void startVisitingConstructorScope(Constructor<?> constructor) {
            startVisitingNewScope();
        }

        protected void finishVisitingConstructorScope(Constructor<?> constructor) {
            finishVisitingNewScope();
        }

        protected void startVisitingMethodScope(Method method) {
            startVisitingNewScope();
        }

        protected void finishVisitingMethodScope(Method method) {
            finishVisitingNewScope();
        }

        protected void finishVisitingField(Field field) {
            if (Modifier.isFinal(field.getModifiers())) {
                currentLine.append("= ");
                currentLine.append(getDefaultValue(field.getType()));
            }
            currentLine.append(';');
            flushLine();
        }

        protected void startVisitingNewScope() {
            currentLine.append("{");
            flushLine();
            indentLevel++;
        }

        protected void finishVisitingNewScope() {
            indentLevel--;
            printCurrentIndent();
            currentLine.append("}");
            flushLine();
        }

        protected void visitMethodScope(Method method) {
            printCurrentIndent();
            currentLine.append("return");
            Class<?> typeClass = method.getReturnType();
            String typeName = typeClass.getTypeName();
            if (!typeName.equals("void")) {
                currentLine.append(' ');
                currentLine.append(getDefaultValue(typeClass));
            }
            currentLine.append(';');
            flushLine();
        }

        private String getDefaultValue(Class<?> typeClass) {
            if (!typeClass.isPrimitive()) {
                return "null";
            }
            return typeClass.getTypeName().equals("boolean") ? "false" : "0";
        }

    }

}
